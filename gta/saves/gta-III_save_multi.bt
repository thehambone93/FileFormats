/*------------------------------------------------------------
 *--- 010 Editor v6.0.2 Binary Template ----------------------
 *
 *             File: gta-III_save_multi.bt
 *           Author: thehambone
 *          Purpose: Documenation of GTA III save file format
 * Contributions by: OrionSR, Seemann, spaceeinstein
 *        Last edit: 23 January 2015
 *----------------------------------------------------------*/

/*************************************************************
 * Info/Features
 * -------------
 * Save files from the following platforms are supported:
 *     Android, iOS, PC, Xbox
 *
 * Platform is automatically detected based on the contents of
 * the file.
 *
 * File checksum is automatically updated when it is in view.
 ************************************************************/

/*************************************************************
 * Variable Naming
 * ---------------
 * (prefixes)
 *  a = array
 *  b = boolean (true or false)
 *  e = enumerated type
 *  f = float
 *  n = number
 *  p = pointer
 * st = struct
 * sz = zero-terminated string
 *  v = vector
 *  _ = unknown data; unclear functionality; unconfirmed
 ************************************************************/

// ---------- TYPE DECLARATIONS ----------
enum <BYTE> BOOL
{
    FALSE_, TRUE_
};

enum <WORD> BOOL16
{
    FALSE__, TRUE__
};

enum <DWORD> BOOL32
{
    FALSE___, TRUE___
};

enum <DWORD> LEVEL
{
    PORTLAND = 1, STAUNTON_ISLAND, SHORESIDE_VALE
};

enum <INT16> WEATHERTYPE
{
    WEATHER_SUNNY, WEATHER_CLOUDY, WEATHER_RAINY, WEATHER_FOGGY
};

enum <INT32> OBJECTTYPE
{
    PATH = 1, STATIC, DYNAMIC_LOADED, DYNAMIC_UNLOADED
};

enum <INT16> VEHICLE16
{
    LANDSTAL_ = 90, IDAHO_, STINGER_, LINERUN_, PEREN_, SENTINEL_, PATRIOT_, FIRETRUK_,
    TRASH_, STRETCH_, MANANA_, INFERNUS_, BLISTA_, PONY_, MULE_, CHEETAH_, AMBULAN_, FBICAR_,
    MOONBEAM_, ESPERANT_, TAXI_, KURUMA_, BOBCAT_, MRWHOOP_, BFINJECT_, CORPSE_, POLICE_,
    ENFORCER_, SECURICA_, BANSHEE_, PREDATOR_, BUS_, RHINO_, BARRACKS_, TRAIN_, CHOPPER_,
    DODO_, COACH_, CABBIE_, STALLION_, RUMPO_, RCBANDIT_, BELLYUP_, MRWONGS_, MAFIA_, YARDIE_,
    YAKUZA_, DIABLOS_, COLOMB_, HOODS_, AIRTRAIN_, DEADDODO_, SPEEDER_, REEFER_, PANLANT_,
    FLATBED_, YANKEE_, ESCAPE_, BORGNINE_, TOYZ_, GHOST_
};

enum <INT32> VEHICLE32
{
    LANDSTAL__ = 90, IDAHO__, STINGER__, LINERUN__, PEREN__, SENTINEL__, PATRIOT__,
    FIRETRUK__, TRASH__, STRETCH__, MANANA__, INFERNUS__, BLISTA__, PONY__, MULE__,
    CHEETAH__, AMBULAN__, FBICAR__, MOONBEAM__, ESPERANT__, TAXI__, KURUMA__, BOBCAT__,
    MRWHOOP__, BFINJECT__, CORPSE__, POLICE__, ENFORCER__, SECURICA__, BANSHEE__, PREDATOR__,
    BUS__, RHINO__, BARRACKS__, TRAIN__, CHOPPER__, DODO__, COACH__, CABBIE__, STALLION__,
    RUMPO__, RCBANDIT__, BELLYUP__, MRWONGS__, MAFIA__, YARDIE__, YAKUZA__, DIABLOS__,
    COLOMB__, HOODS__, AIRTRAIN__, DEADDODO__, SPEEDER__, REEFER__, PANLANT__, FLATBED__,
    YANKEE__, ESCAPE__, BORGNINE__, TOYZ__, GHOST__
};

enum <BYTE> GARAGE
{
    GARAGE_MISSION = 1, GARAGE_BOMBSHOP1, GARAGE_BOMBSHOP2, GARAGE_BOMBSHOP3,
    GARAGE_RESPRAY,GARAGE_COLLECTORSITEMS, GARAGE_COLLECTSPECIFICCARS,
    GARAGE_COLLECTCARS_1, GARAGE_COLLECTCARS_2, GARAGE_COLLECTCARS_3,
    GARAGE_FORCARTOCOMEOUTOF, GARAGE_60SECONDS, GARAGE_CRUSHER, GARAGE_MISSION_KEEPCAR,
    GARAGE_FOR_SCRIPT_TO_OPEN, GARAGE_HIDEOUT_ONE, GARAGE_HIDEOUT_TWO, GARAGE_HIDEOUT_THREE,
    GARAGE_FOR_SCRIPT_TO_OPEN_AND_CLOSE, GARAGE_KEEPS_OPENING_FOR_SPECIFIC_CAR,
    GARAGE_MISSION_KEEPCAR_REMAIN_CLOSED
};

enum <INT32> WEAPON
{
    EMPTY_UNARMED, BAT, PISTOL, UZI, SHOTGUN, AK47, M16, SNIPER_RIFLE,
    ROCKET_LAUNCHER, FLAMETHROWER, MOLOTOV, GRENADE, DETONATOR
};

typedef struct RwV3D
{
    FLOAT   fX;
    FLOAT   fY;
    FLOAT   fZ;
};

typedef struct RestartPoint
{
    RwV3D   vPosition;
    FLOAT   fAngle;
};

typedef struct Zone
{
    char    szName[8];
    RwV3D   vCoordA;
    RwV3D   vCoordB;
    enum <DWORD> ZONETYPE { } eZoneType <comment="0, 1, 2, 3 for MapZone">;
    LEVEL   eZoneLevel;
    WORD    nZoneInfoIDNight;
    WORD    nZoneInfoIDDay;
    INT32   nChildZoneIndex;
    INT32   nParentZoneIndex;
    INT32   nSiblingZoneIndex;
};

typedef struct CPlayerPed
{
    DWORD   pVtbl <comment="virtual method table pointer">;
    RwV3D   _vCameraRoll;
    DWORD   _unknownCMatrix;
    RwV3D   _vCameraDirection;
    DWORD   _pUnknownCMatrix;
    RwV3D   _vCameraWas<comment="name clarification?">;
    DWORD   _pUnknownCMatrix;
    RwV3D   vPosition;
    DWORD   _unknown <comment="related to ped coords; rot?">;
    if (isAndroid || isIOS) {
        BYTE    _unknown1[128];
    } else {
        BYTE    _unknown1[124];
    }
    FLOAT   fWeight;
    FLOAT   _fUnknown1[4];
    BYTE    _unknown2[64];
    FLOAT   _fUnknown2[3];
    DWORD   _unknown;
    DWORD   _unknown;
    RwV3D   _vUnknown[3];
    if (isAndroid || isXbox) {
        BYTE    _bUnknown3[168];
    } else {
        BYTE    _bUnknown3[164];
    }
    DWORD   pPlayerCPed <comment="unconfirmed on all but PC">;
    BYTE    _unknown4[204];
    float   fPlayerHealth;
    float   fPlayerArmor;
    BYTE    _unknown5[148];
    struct
    {
        struct
        {
            WEAPON  eWeaponID;
            DWORD   _nWeaponState;
            DWORD   nClipAmmo;
            DWORD   nWeaponAmmo;
            DWORD   nLastShotTime;
            BYTE    nWeaponCameraMode;
            align(3);
        } aWeaponSlot[13] <optimize=false>;
    } stPlayerWeapons;
    BYTE    _unknown6[12];
    RwV3D   _vUnknown;
    BYTE    _unknown7[72];
    DWORD   pNearestCPeds[10] <comment="unconfirmed on all but PC">;
    BYTE    nLoadedCPeds <comment="unconfirmed on all but PC">;
    if (isAndroid || isIOS) {
        BYTE    _unknown8[47];
    } else {
        BYTE    _unknown8[43];
    }
    FLOAT   fPlayerCurrentStamina;
    FLOAT   fPlayerMaxStamina;
    FLOAT   fSprintDistance;
    if (isAndroid || isIOS) {
        BYTE    _unknown9[184];
    } else {
        BYTE    _unknown9[156];
    }
};

// ---------- DETERMINE PLATFORM ----------
local int isAndroid = 0;
local int isIOS = 0;
local int isPC = 0;
local int isPS2 = 0;
local int isXbox = 0;

if (!determinePlatform()) {
    Printf("Unable to determine platform!\n");
    return;
} else if (isPS2) {
    Printf("PS2 is not yet supported.\n");
    return;
} else {
    Printf("Is Android = %d\n", isAndroid);
    Printf("Is iOS     = %d\n", isIOS);
    Printf("Is PC      = %d\n", isPC);
    Printf("Is PS2     = %d\n", isPS2);
    Printf("Is Xbox    = %d\n", isXbox);
}

// ---------- SAVE FILE STRUCTURE ----------
local int blockCount = countBlocks();
local int n = 0;

struct
{
    DWORD   size;
    switch (n++) {
        case 0: /* BLOCK 0: SIMPLEVARS */
            struct
            {
                if (!isPS2) {
                    wchar_t     szSaveName[24] <comment="(mobile only) GXT ID if first char is 0xFFFF">;
                    if (isPC || isXbox) {
                        struct  SYSTEMTIME
                        {
                            WORD    nYear;
                            enum <WORD> MONTH
                            {
                                JANUARY = 1, FEBRUARY, MARCH, APRIL, MAY, JUNE,
                                JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER
                            } eMonth;
                            enum <WORD> DAY
                            {
                                SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
                                THURSDAY, FRIDAY, SATURDAY
                            } eDayOfWeek;
                            WORD    nDay;
                            WORD    nHour;
                            WORD    nMinute;
                            WORD    nSecond;
                            WORD    nMillisecond;
                        } stTimestamp;
                    }
                }
                DWORD   _unknown <comment="constant 201729">;
                LEVEL   eCurrentLevel;
                RwV3D   vCameraPosition;
                DWORD   nGameMinuteLenghMillis;
                DWORD   nLastClockTick <comment="weather timer">;
                BYTE    nGameHours;
                align(3);
                BYTE    nGameMinutes;
                align(3);
                WORD    _nCurrentPadMode;
                align(2);
                DWORD   nTimeInMilliSeconds <comment="global timer">;
                FLOAT   _fTimeScale <comment="opcode 015D">;
                FLOAT   _fTimerTimeStep;
                FLOAT   _fTimerTimeStepNonClipped;
                DWORD   nFrameCounter;
                FLOAT   _fTimeStep <comment="unused (always 1.0)?">;
                FLOAT   _fFramesPerUpdate <comment="unused (always 1.0)?">;
                FLOAT   _fTimeScale2 <comment="unused (always 1.0)?">;
                WEATHERTYPE nPreviousWeatherType;
                align(2);
                WEATHERTYPE nCurrentWeatherType;
                align(2);
                WEATHERTYPE nForcedWeatherType;
                align(2);
                FLOAT   fWeatherInterpolationValue;
                CHAR    szCompileTime[24] <comment="unused">;
                DWORD  _nWeatherTypeInList;
                if (isPS2) {
                    DWORD   _unknown1[15];
                } else {
                    FLOAT   _fUnknown <comment="camera related">;
                    FLOAT   _fUnknown <comment="camera related">;
                }
                if (isAndroid || isIOS) {
                    DWORD   _unknown;
                }

                DWORD   size;
                struct
                {
                    CHAR    szSCRSig[4] <comment="SCR">;
                    DWORD   size;
                    struct
                    {
                        DWORD   nScriptVariableSpaceSize;
                        DWORD   aScriptVariable[nScriptVariableSpaceSize / sizeof(DWORD)];
                        
                        DWORD   size <comment="968">;
                        struct
                        {
                            DWORD   pOnAMissionFlag <comment="offset in aScriptVariable">;
                            struct
                            {
                                DWORD   pMissionFlag <comment="offset in aScriptVariable; opcode 0181">;
                                DWORD   nBaseBrief <comment="what does this do? opcode 0182">;
                            } aContactInfo[16];
                            struct
                            {
                                DWORD   _unknown[16];
                            } _unknown[4];
                            DWORD   _nLastMissionPassedTime <comment="unused? (always 0)">;
                            struct
                            {
                                OBJECTTYPE  eType;
                                DWORD   nHandle;
                                INT32   nNewModelID;
                                INT32   nOldModelID;
                            } aBuildingSwap[25];
                            struct
                            {
                                OBJECTTYPE  eType;
                                DWORD   nHandle;
                            } aInvisibilitySetting[20] <comment="makes object invisible">;
                            BOOL    bIsAlreadyRunningAMissionScript;
                            align(3);
                            DWORD   nMainScriptSize;
                            DWORD   nLargestMissionScriptSize;
                            WORD    nNumberOfExclusiveMissionScripts <comment="number of missions">;
                            align(2);
                        } stSCMState;
                        DWORD   nNumberOfRunningScripts;
                        struct
                        {
                            DWORD   pNextScript;
                            DWORD   pPreviousScript;
                            CHAR    szName[8];
                            DWORD   pCurrentInstruction;
                            DWORD   aReturnStack[6] <comment="gosub return offset">;
                            WORD    nReturnStackCount;
                            align(2);
                            DWORD   aLocalVariable[16];
                            DWORD   nTimerA;
                            DWORD   nTimerB;
                            BOOL    bIfResult;
                            BOOL    bIsMissionScript;
                            BOOL    bIsActive;
                            align(1);
                            DWORD   nWakeTime <comment="time when next instruction is to be executed">;
                            WORD    nIfNumber <comment="what is this?">;
                            BOOL    bNotFlag;
                            BOOL    bIsWastedBustedCheckEnabled;
                            BOOL    bWastedBustedCheckResult;
                            BOOL    bIsMissionFlag <comment="how does this differ from bIsMissionScript?">;
                            align(2);
                        } aRunningScript[nNumberOfRunningScripts]<optimize=false>;
                    } stTheScriptsData;
                } stTheScripts <name="TheScripts">;
            } block <name="SimpleVars">;
            //if (isPS2) {
            //    BYTE    _unknown[(size + 4) - FTell()];
            //}
            
            break;
        
        case 1: /* BLOCK 1: PLAYERPEDS */
            struct
            {
                DWORD   size;
                struct
                {
                    DWORD   nNumberOfPlayerPeds;
                    struct
                    {
                        DWORD   _unknown;
                        WORD    _unknown;
                        DWORD   _unknown <comment="ped_ref">;
                        CPlayerPed    stCPlayerPedObject;
                        DWORD   nMaxWantedLevel;
                        DWORD   nMaxChaosLevel;
                        CHAR    szModelName[24]<comment="special actor DFF name only">;
                        align(2);
                    } aPlayerPed[nNumberOfPlayerPeds] <optimize=false>;
                } stData;
            } block <name="PlayerPeds">;
            break;

        case 2: /* BLOCK 2: GARAGES */
            struct
            {
                DWORD   size;
                struct
                {
                    DWORD   nNumberOfDefinedGarages;
                    BOOL32  bBombsAreFree <comment="opcode 021D">;
                    BOOL32  bRespraysAreFree <comment="opcode 0335">;
                    DWORD   nCarsCollected <comment="unused?">;
                    DWORD   nBankVansCollected;
                    DWORD   nPoliceCarsCollected <comment="unused?">;
                    DWORD   nCollectCars1Status <format=binary>;
                    DWORD   nCollectCars2Status <format=binary>;
                    DWORD   nCollectCars3Status <format=binary, comment="unused">;
                    DWORD   nTimeLastHelpMessageShown <comment="time 'GA_21' last displayed">;
                    struct
                    {
                        struct
                        {
                            VEHICLE32   eModelID;
                            RwV3D       vPosition;
                            float       vRotation[3] <comment="how does this work? euler angles?">;
                            DWORD       nImmunities <format=binary>;
                            BYTE        nPrimaryColorID;
                            BYTE        nSecondaryColorID;
                            enum <BYTE>
                            {
                                HEAD_RADIO, DOUBLE_CLEF_FM, JAH_RADIO, RISE_FM, LIPS_106,
                                GAME_FM, MSX_FM, FLASHBACK_95_6, CHATTERBOX_109, USER_TRACK_PLAYER,
                                POLICE_RADIO, RADIO_OFF
                            } eRadioStation;
                            BYTE    nModelVariationA;
                            BYTE    nModelVariationB;
                            enum <BYTE>
                            {
                                NO_BOMB, TIMER_BOMB, IGNITION_BOMB, REMOTE_BOMB,
                                TIMER_BOMB_ARMED, IGNITION_BOMB_ARMED
                            } eBomb;
                            align(2);
                        } aStoredCar[3] <optimize=false, comment="portland, staunton, shoreside">;
                    } aSaveCarGarageSlot[6] <optimize=false, comment="1 per island">;
                    struct
                    {
                        GARAGE  eType;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        align(2);
                        DWORD   _unknown;
                        DWORD   _pUnknown <comment="pointer">;
                        DWORD   _pUnknown <comment="pointer">;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        align(1);
                        FLOAT   fX1;
                        FLOAT   fX2;
                        FLOAT   fY1;
                        FLOAT   fY2;
                        FLOAT   fZ1;
                        FLOAT   fZ2;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        DWORD   _unknown;
                        BYTE    _unknown;
                        align(3);
                        DWORD   _unknown;
                        DWORD   _unknown;
                        DWORD   _unknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        DWORD   _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        align(2);
                    } aGarage[32] <optimize=false, comment="constant 32">;
                } stGarageData;
            } block <name="Garages">;
            break;

        case 3: /* BLOCK 3: VEHICLES */
            struct
            {
                DWORD   size;
                struct
                {
                    DWORD   nNumberOfCars;
                    DWORD   nNumberOfBoats;
                    struct
                    {
                        DWORD   _unknown;
                        VEHICLE16    eModelID;
                        DWORD   _unknown;
                        struct  CVehicle
                        {
                            BYTE    _unknown0[52];
                            RwV3D   vPosition;
                            BYTE    _unknown1[1384];
                        } stCVehicleDump;
                    } aCar[nNumberOfCars] <optimize=false>;
                    struct
                    {
                        DWORD   _unknown;
                        VEHICLE16    eModelID;
                        DWORD   _unknown;
                        struct  CBoat
                        {
                            BYTE    _unknown0[52];
                            RwV3D   vPosition;
                            BYTE    _unknown1[1092];
                        } stCBoatDump;
                    } aBoat[nNumberOfBoats] <optimize=false>;
                } stVehiclesData;
            } block <name="Vehicles">;
            break;

        case 4: /* BLOCK 4: OBJECTS */
            struct
            {
                DWORD   size;
                struct
                {
                    DWORD   nNumberOfObjects;
                    struct
                    {
                        WORD    nModelID;
                        DWORD   nObjRef;
                        RwV3D   vPosition;
                        BYTE    _unknown1[12] <comment="compressed matrix (what is this?)">;
                        FLOAT   _unknown;
                        RwV3D   _unknown;
                        BYTE    _unknown2[12] <comment="compressed matrix (what is this?)">;
                        BYTE    _unknown3[8];
                        FLOAT   _unknown;
                        BYTE    _unknown;
                        BYTE    _unknown;
                        DWORD   _unknown;
                        DWORD   _unknown;
                        if (isIOS) {
                            WORD    _unknown;
                        } else {
                            DWORD   _unknown;
                        }
                    } aObject[nNumberOfObjects] <optimize=false>;
                } stObjectsData;
            } block <name="Objects">;
            break;

        case 5: /* BLOCK 5: PATH FIND */
            struct
            {
                DWORD size;
                struct
                {
                    BYTE    aDisabledPedNodes[size / 2] <format=binary, optimize=false, comment="how does this work?">;
                    BYTE    aDisabledCarNodes[size / 2] <format=binary, optimize=false, comment="how does this work?">;
                } stPathFindData;
            } block <name="PathFind">;
            break;

        case 6: /* BLOCK 6: CRANES */
            struct
            {
                DWORD   size;
                struct
                {
                    DWORD   nNumberOfCranes;
                    DWORD   nEVCraneCollectCarsStatus <format=binary, comment="opcode 03EC">;
                    struct
                    {
                        DWORD   nStaticObjectIndex;
                        DWORD   nCraneHookObjectIndex <comment="index in objects pool">;
                        DWORD   nAudioEntityIndex;
                        struct
                        {
                            FLOAT   fPickupZoneX1 <comment="param 3">;
                            FLOAT   fPickupZoneX2 <comment="param 5">;
                            FLOAT   fPickupZoneY1 <comment="param 6">;
                            FLOAT   fPickupZoneY2 <comment="param 4">;
                        } stPickupZone <comment="opcode 01EE">;
                        struct
                        {
                            FLOAT   fDropOffPointX <comment="param 7">;
                            FLOAT   fDropOffPointY <comment="param 8">;
                            FLOAT   fDropOffPointZ <comment="param 9">;
                            FLOAT   fDropOffHeading <comment="param 10; radians">;
                        } stDropOffPoint <comment="opcode 01EE">;
                        struct
                        {
                            FLOAT   fArmPickupRotation <comment="radians">;
                            FLOAT   fArmDropOffRotation <comment="radians">;
                            FLOAT   fArmPickupDistance <comment="distance from center of crane">;
                            FLOAT   fArmDropOffDistance <comment="distance from center of crane">;
                            FLOAT   fArmPickupHeight;
                            FLOAT   fArmDropOffHeight;
                            FLOAT   fArmCurrentRotation <comment="radians">;
                            FLOAT   fArmCurrentDistance <comment="distance from center of crane">;
                            FLOAT   fArmCurrentHeight;
                        } stCraneArm;
                        RwV3D   vHookInitialPosition;
                        RwV3D   vHookCurrentPosition;
                        FLOAT   _fUnknown;
                        FLOAT   _fUnknown;
                        DWORD   pVehicle <comment="pointer to vehicle pick up">;
                        DWORD   nTime <comment="current game time + 10000; updates when crane has finished lifting car">;
                        enum <BYTE>
                        {
                            CRANE_IDLE,
                            CRUSHER_MILITARY_CRANE_ACTIVE,
                            CRANE_INACTIVE
                        } eCraneActivity;
                        enum <BYTE>
                        {
                            MOTION_IDLE, MOVING_TO_PICKUP, MOVING_UPWARDS_FROM_PICKUP, MOVING_TO_DESTINATION,
                            MOVING_DOWNWARDS_TO_DROPOFF, MOVING_UPWARDS_FROM_DROPOFF
                        } eCraneStatus;
                        BYTE    nNumberOfVehiclesCollected;
                        BOOL    bIsCrusherCrane;
                        BOOL    bIsMilitaryCrane;
                        BYTE    _bUnknown;
                        BOOL    bModelIsNotDocCraneCab <comment="model is not doc_crane_cab">;
                        align(1);
                    } aCrane[nNumberOfCranes] <optimize=false>;

                } stCraneData;
            } block <name="Cranes", comment="Get info from spaceeinstein">;
            break;

        case 7: /* BLOCK 7: PICKUPS */
            struct
            {
                DWORD   size;
                struct
                {
                    struct
                    {
                        enum <BYTE>
                        {
                            PICKUP_IN_SHOP = 1,
                            PICKUP_ON_STREET,
                            PICKUP_ONCE,
                            PICKUP_ONCE_TIMEOUT,
                            PICKUP_COLLECTIBLE1,
                            PICKUP_IN_SHOP_OUT_OF_STOCK,
                            PICKUP_MONEY,
                            PICKUP_MINE_INACTIVE,
                            PICKUP_MINE_ARMED,
                            PICKUP_NAUTICAL_MINE_INACTIVE,
                            PICKUP_NAUTICAL_MINE_ARMED,
                            PICKUP_FLOATING_PACKAGE,
                            PICKUP_FLOATING_PACKAGE_FLOATING,
                            PICKUP_ON_STREET_SLOW
                        } ePickupType;
                        BYTE    _bUnknown;
                        WORD    nAmmo;
                        DWORD   nObjectIndex;
                        DWORD   nRegenerateTime;
                        WORD    nModelID;
                        WORD    nFlags <format=binary>;
                        RwV3D   vPosition;
                    } aPickup[336] <optimize=false, comment="always 336?">;
                    WORD    _nNumberOfPickupsCollected;
                    align(2);
                    struct
                    {
                        DWORD _unknown;
                        DWORD _unknown;
                        DWORD _unknown;
                        DWORD _unknown;
                        DWORD _unknown;
                    } _aCollectedPickup[4] <optimize=false>;
                } stPickupsData;
            } block <name="Pickups">;
            break;

        case 8: /* BLOCK 8: PHONE INFO */
            struct
            {
                DWORD   size;
                struct
                {
                    DWORD   nNumberOfPhones;
                    DWORD   nNumberOfActivePhones;
                    struct
                    {
                        RwV3D   vPosition;
                        DWORD   pText[6] <comment="pointers to message string; opcodes 024B, 024C, 0378, 0379, 037A, 037B, 037C, 037D, 0386, 0387, 0388, 0389">;
                        DWORD   nMessageTimer <comment="game timer when message ends for states 5 and 6">;
                        DWORD   nStaticObjectIndex <comment="index in static objects pool">;
                        enum <DWORD>
                        {
                            PHONE_IDLE = 3,
                            RINGING_MESSAGE_ONCE,
                            RINGING_MESSAGE_REPEATED_NOT_PICKED_UP,
                            RINGING_MESSAGE_REPEATED_PICKED_UP,
                            IDLE_FINISHED_MESSAGE_ONCE,
                            IDLE_FINISHED_MESSAGE_REPEATED,
                            RINGING
                        } ePhoneStatus;
                        BOOL    bIsPlayerInRangeOfPhone;
                        align(3);
                    } aPhoneInfo[nNumberOfPhones] <optimize=false>;
                } stPhoneInfoData;
            } block <name="PhoneInfo">;
            break;

        case 9: /* BLOCK 9: RESTARTS */
            struct
            {
                DWORD   size;
                struct
                {
                    char    szRSTSig[4] <comment="RST">;
                    DWORD   size;
                    struct
                    {
                        RestartPoint    aWastedRestart[8] <comment="opcode 016C">;
                        RestartPoint    aBustedRestart[8] <comment="opcode 016D">;
                        WORD    nNumberOfActiveWastedRestarts;
                        WORD    nNumberOfActiveBustedRestarts;
                        BOOL    bOverrideNextRestart <comment="opcodes 016E, 0255">;
                        align(3);
                        RestartPoint    stOverriddenRestartPoint <comment="opcodes 016E, 0255">;
                        BOOL    bFadeInAfterNextDeath <comment="opcodes 040F">;
                        BOOL    bFadeInAfterNextArrest <comment="opcodes 040E">;
                        BOOL    bOverrideHospitalLevel <comment="opcodes 041F">;
                        BOOL    bOverridePoliceLevel <comment="opcodes 0420">;
                    } stRestartData;
                } stRestarts;
            } block <name="Restarts">;
            break;

       case 10: /* BLOCK 10: RADAR */
            struct
            {
                DWORD   size;
                struct
                {
                    char    szRDRSig[4] <comment="RDR">;
                    DWORD   size;
                    struct
                    {
                        DWORD   nColor <comment="opcode 0165">;
                        DWORD   nType;
                        DWORD   nEntityHandle <comment="car/actor/object handle">;
                        FLOAT   fRadarPositionX;
                        FLOAT   fRadarPositionY;
                        RwV3D   vWorldPosition;
                        WORD    _nIndex;
                        BYTE    nBrightness <comment="opcode 0166">;
                        BOOL    bIsVisible;
                        FLOAT   _unknown;
                        WORD    nScale <comment="opcode 0168">;
                        WORD    nDisplay <comment="opcode 018B">;
                        enum <WORD>
                        {
                            RADAR_DEFAULT, RADAR_ASUKA, RADAR_BOMB, RADAR_CAT, RADAR_CENTRE,
                            RADAR_COPCAR, RADAR_DON, RADAR_EIGHT, RADAR_EL, RADAR_ICE, RADAR_JOEY,
                            RADAR_KENJI, RADAR_LIZ, RADAR_LUIGI, RADAR_NORTH, RADAR_RAY, RADAR,SAL,
                            RADAR_SAVE, RADAR_SPRAY, RADAR_TONY, RADAR_WEAPON
                        } eBlipSprite;
                        align(2);
                    } aRadarBlip[32] <optimize=false, comment="constant 32">;
                } stRadar;
            } block <name="Radar">;
            break;

        case 11: /* BLOCK 11: THE ZONES */
            struct
            {
                DWORD   size;
                struct
                {
                    char    szZNSSig[4] <comment="ZNS">;
                    DWORD   size;
                    struct
                    {
                        DWORD   nCurrentZoneIndex;
                        LEVEL   eCurrentLevel;
                        WORD    nFindIndex <comment="index of last search invoked by a script">;
                        align(2);
                        Zone    aNavigationZone[50] <comment="from gta3.zon">;
                        struct
                        {
                            WORD    aDensity[29];
                        } aZoneInfo[100] <comment="day/night pairs for each zone">;
                        WORD    nNumberOfNavigationZones;
                        WORD    nNumberOfZoneInfos;
                        Zone    aMapZone[25] <comment="from map.zon">;
                        struct
                        {
                            INT16   nZoneID;
                        } stAudioZone[36];
                        WORD    nNumberOfMapZones;
                        WORD    nNumberOfAudioZones;
                    } stTheZonesData;
                } stTheZones;
            } block <name="TheZones">;
            break;

        case 12: /* BLOCK 12: GANGS */
            struct
            {
                DWORD   size;
                struct
                {
                    char    szGNGSig[4] <comment="GNG">;
                    DWORD   size;
                    struct
                    {
                        VEHICLE32   eVehicleModelID <comment="opcode 0236">;
                        BYTE    nPedModelOverrideIndex <comment="opcode 0410">;
                        align(3);
                        WEAPON  eWeaponID1 <comment="opcode 0237">;
                        WEAPON  eWeaponID2 <comment="opcode 0237">;
                    } aGang[9] <optimize=false>;
                } stGangs;
            } block <name="Gangs">;
           break;

        case 13: /* BLOCK 13: THE CAR GENERATORS */
            struct
            {
                DWORD   size;
                struct
                {
                    char    szCGNSig[4] <comment="CGN">;
                    DWORD   size;
                    struct
                    {
                        DWORD   size <comment="constant 12">;
                        struct
                        {
                            DWORD   nNumberOfCarGenerators;
                            DWORD   nActiveCarGeneratorsCount;
                            BYTE    _nProcessCounter;
                            BYTE    _nGenerateEvenIfPlayerIsCloseCounter;
                            align(2);
                        } stMetaData;
                        DWORD   size <comment="constant 11560">;
                        struct
                        {
                            VEHICLE32   eModelID;
                            RwV3D   vPosition;
                            FLOAT   fAngle;
                            INT16   nPrimaryColorID <comment="color ID from carcols.dat">;
                            INT16   nSecondaryColorID <comment="color ID from carcols.dat">;
                            BOOL    bForceSpawn;
                            BYTE    nAlarm <comment="percent chance of vehilce spawning with alarm">;
                            BYTE    nDoorLock <comment="percent chance of vehilce spawning with locked doors">;
                            align(1);
                            WORD    nMinDelay;
                            WORD    nMaxDelay;
                            DWORD   nTime;
                            INT32   _unknown24;
                            INT16   _unknown28 <comment="spawn counter?">;
                            WORD    _unknown2A;
                            RwV3D   _vUnknown2C;
                            RwV3D   _vUnknown38;
                            DWORD   _unknown <comment="pointer?">;
                        } aCarGenerator[160] <optimize=false>;
                    } stTheCarGeneratorsData;
                } stTheCarGenerators;
            } block <name="TheCarGenerators">;
            break;

        case 14: /* BLOCK 14: PARTICLES */
            struct
            {
                DWORD   size;
                struct
                {
                    DWORD   nNumberOfParticles;
                    struct
                    {
                        DWORD   pVtbl <comment="pointer to virtual method table">;
                        FLOAT   _fUnknown04;
                        DWORD   _unknown08;
                        DWORD   _unknown0C;
                        DWORD   _unknown10;
                        DWORD   _unknown14;
                        FLOAT   _fUnknown18;
                        DWORD   _unknown1C;
                        DWORD   _unknown20;
                        DWORD   _unknown24;
                        DWORD   _unknown28;
                        FLOAT   _fUnknown2C;
                        DWORD   _unknown30;
                        RwV3D   _vUnknown34;
                        DWORD   _unknown40;
                        DWORD   _unknown44;
                        DWORD   _unknown48;
                        UINT32  pNext;
                        UINT32  pPrev;
                        DWORD   _unknown54;
                        DWORD   _nTime;
                        DWORD   _unknown5C;
                        DWORD   _unknown60;
                        BYTE    _unknown64;
                        BYTE    _unknown65;
                        WORD    _unknown66;
                        WORD    _unknown68;
                        align(2); /*?*/
                        FLOAT   _fUnknown6C;
                        FLOAT   _fUnknown70;
                        FLOAT   _fUnknown74;
                        FLOAT   _fUnknown78;
                        FLOAT   _fUnknown7C;
                        BYTE    _unknown80;
                        BYTE    _unknown81;
                        BYTE    _unknown82;
                        BYTE    _unknown83;
                        BYTE    _unknown84;
                        BYTE    _unknown85;
                        align(2);
                    } aParticle[nNumberOfParticles] <optimize=false>;
                    align(136);
                } stParticles;
            } block <name="Particles">;
            break;

        case 15: /* BLOCK 15: AUDIO SCRIPT OBJECTS */
            struct
            {
                DWORD   size;
                struct
                {
                    char    szAUDSig[4] <comment="AUD">;
                    DWORD   size;
                    struct
                    {
                        DWORD   nNumberOfAudioScriptObjects;
                        struct
                        {
                            DWORD   _nIndex;
                            WORD    _nSoundIndex;
                            align(2);
                            RwV3D   vPosition;
                            DWORD   _unknown;
                        } aAudioScriptObject[nNumberOfAudioScriptObjects] <optimize=false>;
                    } stAudioScriptObjectsData;
                } stAudioScriptObjects;
            } block <name="AudioScriptObjects">;
            break;

        case 16: /* BLOCK 16: PLAYER INFO */
            struct
            {
                DWORD   size;
                struct
                {
                    INT32   nMoney;
                    BYTE    _bUnknown04;
                    DWORD   _unknown05;
                    WORD    _unknown09;
                    FLOAT   _fUnknown0B;
                    INT32   nMoneyOnScreen;
                    DWORD   nHiddenPackagesCollected;
                    DWORD   nHiddenPackagesCount <comment="opcode 02ED">;
                    BOOL    bPlayerNeverGetsTired <comment="opcode 0330">;
                    BOOL    bPlayerFastReload <comment="opcode 0331; doesn't appear to have any effect">;
                    BOOL    bPlayerGetOutOfJailFree <comment="opcode 0413">;
                    BOOL    bPlayerFreeHealthCare <comment="opcode 0414">;
                    BYTE    _unknown[70];
                    align(215);
                } stPlayerInfo;
            } block <name="PlayerInfo">;
            break;

        case 17: /* BLOCK 17: STATS */
            struct
            {
                DWORD   size;
                struct
                {
                    DWORD   nPeopleYouveWasted;
                    DWORD   nPeopleWastedByOthers;
                    DWORD   nCarsExploded;
                    DWORD   nShotsMade <comment="what is this?">;
                    DWORD   nPedTypeWasted[23] <comment="index in array cooresponds with pedtype ID">;
                    DWORD   nHelicoptersDestroyed;
                    DWORD   nCurrentProgressPoints <comment="opcode 030C">;
                    DWORD   nTotalProgressPoints <comment="opcode 030D">;
                    DWORD   nKgsOfExplosivesUsed;
                    DWORD   nBulletsFired;
                    DWORD   nBulletsThatHit;
                    DWORD   nCarsCrushed;
                    DWORD   nHeadShotsMade;
                    DWORD   nTimesBusted;
                    DWORD   nHospitalVisits;
                    DWORD   nDaysPassedInGame;
                    DWORD   nMmRainFallen;
                    FLOAT   fMaxInsaneJumpDistance;
                    FLOAT   fMaxInsaneJumpHeight;
                    DWORD   nMaxInsaneJumpFlips;
                    DWORD   nMaxInsaneJumpRotation;
                    enum <DWORD>
                    {
                        NoInsaneStuntsCompleted,
                        InsaneStunt,
                        PerfectInsaneStunt,
                        DoubleInsaneStunt,
                        PerfectDoubleInsaneStunt,
                        TripleInsaneStunt,
                        PerfectTripleInsaneStunt,
                        QuadrupleInsaneStunt,
                        PerfectQuadrupleInsaneStunt,
                    } eBestInsaneStuntSoFar <comment="opcode 0312">;
                    DWORD   nUniqueStuntJumpsCompleted <comment="opcode 0313">;
                    DWORD   nTotalUniqueStuntJumps <comment="opcode 0314">;
                    DWORD   nMissionAttempts <comment="opcode 0317">;
                    DWORD   nMissionsPassed <comment="opcode 0318">;
                    DWORD   nPassengersDroppedOff <comment="opcode 0315">;
                    DWORD   nCashMadeInTaxi <comment="opcode 0316">;
                    BOOL32  bIndustrialPassed <comment="opcode 034A">;
                    BOOL32  bCommercialPassed <comment="opcode 034B">;
                    BOOL32  bSuburbanPassed <comment="opcode 034C">;
                    DWORD   nElBurroTime <comment="Best Turismo time in secs; opcode 03E2">;
                    FLOAT   fDistanceTravelledOnFoot;
                    FLOAT   fDistanceTravelledByCar;
                    DWORD   n4x4OneTime <comment="Patriot Playground in secs; opcode 03FD">;
                    DWORD   n4x4TwoTime <comment="A Ride in the Park in secs; opcode 03FE">;
                    DWORD   n4x4ThreeTime <comment="Gripped! in secs; opcode 03FF">;
                    DWORD   n4x4MayhemTime <comment="Multistorey Mayhem in secs; opcode 0400">;
                    DWORD   nPeopleSavedInAnAmbulance <comment="opcode 0401">;
                    DWORD   nCriminalsKilledOnVigilanteMission <comment="opcode 0402">;
                    DWORD   nHighestParamedicMissionLevel <comment="opcode 0403">;
                    DWORD   nTotalFiresExtinguished <comment="opcode 0404">;
                    DWORD   nLongestFlightInDodo <comment="opcode 0406">;
                    DWORD   nBestTimeForBombDefusal <comment="Rigged to Blow best time; opcode 0407">;
                    DWORD   nRampagesPassed <comment="opcode 041B">;
                    DWORD   nTotalRampages <comment="opcode 0408">;
                    DWORD   nTotalMissions <comment="opcode 042C">;
                    DWORD   nFastestTimeRecord[16] <comment="opcode 042E; unused">;
                    struct
                    {
                        DWORD   nBlingBlingScrambleMostCheckpoints;
                        DWORD   nDiabloDestructionGangCarsTotalled;
                        DWORD   nMafiaMassacreGangCarsTotalled;
                        DWORD   nCasinoCalamityGangCarsTotalled;
                        DWORD   nRumpoWreckerGangCarsTotalled;
                        DWORD   nUnusedHighScores[11];
                    } nHighestScoreRecord <comment="opcode 042F">;
                    DWORD   nPeopleKilledSinceLastCheckpoint;
                    DWORD   nPeopleKilledNoWastedBusted;
                    CHAR    szLastMissionPassedName[8] <comment="GXY key">;
                } stStats;
            } block <name="Stats">;
            break;

        case 18: /* BLOCK 18: STREAMING */
            struct
            {
                DWORD   size;
                struct
                {
                    BYTE    _unknown[200];
                } stStreaming;
            } block <name="Streaming">;
            break;

        case 19: /* BLOCK 19: PED TYPES */
            struct
            {
                DWORD   size;
                struct
                {
                    CHAR    szPTPSig[4] <comment="PTP">;
                    DWORD   size;
                    struct
                    {
                        DWORD   _unknown00 <format=binary, comment="ped type mask? set bit seems to coorespond to ped type ID (index in array) for most structures">;
                        FLOAT   _fUnknown04;
                        FLOAT   _fUnknown08;
                        FLOAT   _fUnknown0C;
                        FLOAT   fFleeDistance <comment="see pedstats.dat">;
                        FLOAT   fHeadingChangeRate <comment="degrees; see pedstats.dat">;
                        DWORD   nThreatFlags <format=binary, comment="threat flags, each bit index cooresponds with pedtype ID; opcodes 03F1, 03F2, 042A; see ped.dat">;
                        DWORD   nAvoidFlags <format=binary, comment="avoid flags; see ped.dat">;
                    } aPedType[23] <optimize=false>;
                } stPedTypes;
            } block <name="PedTypes">;
            break;

        default: /* BLOCK N: PADDING */
            struct
            {
                align(size);
            } block <name="Padding">;
    }
    if (size > sizeof(block)) {
        align(size - sizeof(block));
    }
} stBlock[blockCount] <optimize=false, open=true>;

DWORD checksum <read=checksum>;
if (isXbox) {
    DWORD _unknown[5];
}

// ---------- FUNCTIONS ----------
string checksum(int oldSum)
{
    local int checksumOffset = 0;
    local uint32 newSum;
    local string newSumString;

    if (isXbox) {
        checksumOffset = FileSize() - 24;
    } else {
        checksumOffset = FileSize() - 4;
    }

    newSum = Checksum(CHECKSUM_BYTE, 0, checksumOffset);
    if (newSum != oldSum) {
        WriteUInt(checksumOffset, newSum);
    }

    SPrintf(newSumString, "%d", (uint32) newSum);
    return newSumString;
}

int determinePlatform()
{
    // This value is present in block 0 of every save file.
    // Its purpose is unknown.
    local int UNKNOWN_CONSTANT = 201729;

    local int foundPlatform;
    local int isPCOrXbox;
    local int isMobile;
    local int scrOffset;
    local int sizeOfBlock1;
    
    // Determine platform using data from block 0
    scrOffset = FindFirst("SCR\0");
    if (scrOffset == 0xB8           // Mobile
            && ReadInt(0x34) == UNKNOWN_CONSTANT) {
        isMobile = 1;
    } else if (scrOffset == 0xC4    // PC or Xbox
            && ReadInt(0x44) == UNKNOWN_CONSTANT) {
        isPCOrXbox = 1;
    } else if (scrOffset == 0xB8    // PS2
            && ReadInt(0x04) == UNKNOWN_CONSTANT) {
        isPS2 = 1;
        foundPlatform = 1;
    }

    // Determine platform using size of block 1
    sizeOfBlock1 = ReadInt(ReadInt(0x00) + 0x04);
    if (isMobile) {
        if (sizeOfBlock1 == 0x064C) {
            isAndroid = 1;
            foundPlatform = 1;
        } else if (sizeOfBlock1 == 0x0648) {
            isIOS = 1;
            foundPlatform = 1;
        }
    } else if (isPCOrXbox) {
        if (sizeOfBlock1 == 0x0624) {
            isPC = 1;
            foundPlatform = 1;
        } else if (sizeOfBlock1 == 0x0628) {
            isXbox = 1;
            foundPlatform = 1;
        }
    }
    
    return foundPlatform;
}

int countBlocks()
{
    local int mark = FTell();
    local int blockCount = 0;

    FSeek(0);
    while (FTell() < FileSize()) {
        FSkip(ReadInt() + 4);
        blockCount++;
    }
    FSeek(mark);

    return blockCount - 1;
}

void align(int n)
{
    FSkip(n);
}
